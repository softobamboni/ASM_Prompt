ca65 V2.19 - Git d7d1d8969
Main file   : asmprompt.asm
Current file: asmprompt.asm

000000r 1               .org $080D
00080D  1               .segment "STARTUP"
00080D  1               .segment "INIT"
00080D  1               .segment "ONCE"
00080D  1               .segment "CODE"
00080D  1               
00080D  1  4C 10 08        jmp start
000810  1               
000810  1               ; zero page variables
000810  1               ZP = $30
000810  1               LD = $22
000810  1               AR = $25
000810  1               XR = $26
000810  1               YR = $27
000810  1               SR = $28
000810  1               
000810  1               ; character variables
000810  1               backspace = $14
000810  1               escape = $1B
000810  1               
000810  1               ;KERNAL subroutines
000810  1               CHRIN = $FFCF
000810  1               CHROUT = $FFD2
000810  1               
000810  1               .macro lds
000810  1                   lda SR
000810  1                   pha
000810  1                   plp
000810  1               .endmacro
000810  1               
000810  1               .macro sts
000810  1                   php
000810  1                   pla
000810  1                   sta SR
000810  1               .endmacro
000810  1               
000810  1               start:
000810  1  64 23            stz $23             ;zero out the value for setting the nibble skip
000812  1  64 24            stz $24             ;zero out the value for nibble skip
000814  1  A9 0D            lda #$0D            ;enter
000816  1  20 D2 FF         jsr CHROUT          ;new line
000819  1  A2 00            ldx #0              ;zero out the index
00081B  1               input:
00081B  1  20 CF FF         jsr CHRIN           ;input from keyboard
00081E  1  C9 0D            cmp #$0D            ;check for enter
000820  1  D0 03            bne cont            ;not enter
000822  1  4C 0D 09         jmp check           ;enter pressed, input has ended, time to check
000825  1               cont:
000825  1  C9 14            cmp #backspace      ;has backspace been inputed?
000827  1  D0 05            bne next            ;no
000829  1  E0 00            cpx #0
00082B  1  F0 EE            beq input           ;yes, but nothing had been written yet
00082D  1  CA               dex                 ;backspace, decrement the index
00082E  1               next:
00082E  1  C9 20            cmp #$20            ;is it a valid character?
000830  1  30 E9            bmi input           ;no, go back
000832  1  C9 5B            cmp #'z'+1          ;is it a letter, symbol or a number?
000834  1  10 E5            bpl input           ;no, go back
000836  1  95 30            sta ZP,x            ;store the character
000838  1  E8               inx                 ;increment the index
000839  1  80 E0            bra input           ;check for more characters
00083B  1               incy:                   ;some functions are here because 65c02 is able to branch backwards
00083B  1  C9 59            cmp #'y'
00083D  1  D0 4E            bne err3            ;see later code comments to figure out how this code works it's simular
00083F  1  A5 28 48 28      lds
000843  1  A4 27            ldy YR
000845  1  C8               iny
000846  1  84 27            sty YR
000848  1  08 68 85 28      sts
00084C  1  4C 10 08         jmp start
00084F  1               inca:
00084F  1  C9 43            cmp #'c'
000851  1  D0 E8            bne incy
000853  1  A5 28 48 28      lds
000857  1  A5 25            lda AR
000859  1  1A               inc
00085A  1  85 25            sta AR
00085C  1  08 68 85 28      sts
000860  1  4C 10 08         jmp start
000863  1               as:
000863  1  C9 4C            cmp #'l'
000865  1  D0 26            bne err3
000867  1  A5 28 48 28      lds
00086B  1  A5 25            lda AR
00086D  1  0A               asl
00086E  1  85 25            sta AR
000870  1  08 68 85 28      sts
000874  1  4C 10 08         jmp start
000877  1               ty:
000877  1  C9 41            cmp #'a'
000879  1  D0 12            bne err3
00087B  1  A5 27            lda YR
00087D  1  85 25            sta AR
00087F  1  4C 10 08         jmp start
000882  1               ta:
000882  1  C9 58            cmp #'x'
000884  1  D0 15            bne taty
000886  1  A5 25            lda AR
000888  1  85 26            sta XR
00088A  1  4C 10 08         jmp start
00088D  1               err3:
00088D  1  4C 8F 0A         jmp err         ;jump to error handler
000890  1               tx:
000890  1  C9 41            cmp #'a'
000892  1  D0 F9            bne err3
000894  1  A5 26            lda XR
000896  1  85 25            sta AR
000898  1  4C 10 08         jmp start
00089B  1               taty:
00089B  1  C9 59            cmp #'y'
00089D  1  D0 EE            bne err3
00089F  1  A5 25            lda AR
0008A1  1  85 27            sta YR
0008A3  1  4C 10 08         jmp start
0008A6  1               i:
0008A6  1  C0 4E            cpy #'n'
0008A8  1  D0 E3            bne err3
0008AA  1  C9 58            cmp #'x'
0008AC  1  D0 A1            bne inca
0008AE  1  A5 28 48 28      lds
0008B2  1  A6 26            ldx XR
0008B4  1  E8               inx
0008B5  1  86 26            stx XR
0008B7  1  08 68 85 28      sts
0008BB  1  4C 10 08         jmp start
0008BE  1               an:
0008BE  1  C0 44            cpy #'d'
0008C0  1  F0 13            beq ad
0008C2  1  C0 53            cpy #'s'
0008C4  1  F0 9D            beq as
0008C6  1  C0 4E            cpy #'n'
0008C8  1  D0 C3            bne err3
0008CA  1  C9 44            cmp #'d'
0008CC  1  D0 BF            bne err3
0008CE  1  A2 2D            ldx #$2D
0008D0  1  A0 29            ldy #$29
0008D2  1  4C 2E 0A         jmp load
0008D5  1               ad:
0008D5  1  C9 43            cmp #'c'
0008D7  1  D0 B4            bne err3
0008D9  1  A2 6D            ldx #$6d
0008DB  1  A0 69            ldy #$69
0008DD  1  4C 2E 0A         jmp load
0008E0  1               t:
0008E0  1  C0 41            cpy #'a'
0008E2  1  F0 9E            beq ta
0008E4  1  C0 58            cpy #'x'
0008E6  1  F0 A8            beq tx
0008E8  1  C0 59            cpy #'y'
0008EA  1  F0 8B            beq ty
0008EC  1  4C 8F 0A         jmp err
0008EF  1               e:
0008EF  1  C0 4F            cpy #'o'
0008F1  1  D0 9A            bne err3
0008F3  1  C9 52            cmp #'r'
0008F5  1  D0 96            bne err3
0008F7  1  A2 4D            ldx #$4D
0008F9  1  A0 49            ldy #$49
0008FB  1  4C 2E 0A         jmp load
0008FE  1               o:
0008FE  1  C0 52            cpy #'r'
000900  1  D0 8B            bne err3
000902  1  C9 41            cmp #'a'
000904  1  D0 87            bne err3
000906  1  A2 0D            ldx #$0D
000908  1  A0 09            ldy #$09
00090A  1  4C 2E 0A         jmp load
00090D  1               check:              ;what has been stored in memory?
00090D  1  74 30            stz ZP,x        ;terminate the string
00090F  1  A6 30            ldx ZP
000911  1  A4 31            ldy ZP+1        ;load three first symbols into registers (1-x, 2-y, 3-a)
000913  1  A5 32            lda ZP+2        ;every implimented instruction consists of three letters
000915  1  E0 4F            cpx #'o'        ;check for first letter
000917  1  F0 E5            beq o
000919  1  E0 45            cpx #'e'
00091B  1  F0 D2            beq e
00091D  1  E0 49            cpx #'i'
00091F  1  F0 85            beq i
000921  1  E0 4C            cpx #'l'
000923  1  F0 46            beq l
000925  1  E0 4A            cpx #'j'
000927  1  F0 51            beq j
000929  1  E0 41            cpx #'a'
00092B  1  F0 91            beq an
00092D  1  E0 53            cpx #'s'
00092F  1  F0 5B            beq s
000931  1  E0 43            cpx #'c'
000933  1  F0 0D            beq c
000935  1  E0 52            cpx #'r'
000937  1  F0 1A            beq r
000939  1  E0 54            cpx #'t'
00093B  1  F0 A3            beq t
00093D  1  E0 51            cpx #'q'
00093F  1  D0 48            bne err2        ;invalid symbol, give an error
000941  1  60               rts             ;q has been written, quit the program
000942  1               c:                  ;c is the first letter, check if "clc" instruction has been written
000942  1  C0 4C            cpy #'l'
000944  1  D0 43            bne err2        ;error out
000946  1  C9 43            cmp #'c'
000948  1  D0 3F            bne err2
00094A  1  A5 28            lda SR          ;load the status register
00094C  1  29 FE            and #%11111110  ;and mask to clear the carry flag (last bit) and leave other flags unchanged
00094E  1  85 28            sta SR          ;store the modified status register
000950  1  4C 10 08         jmp start       ;go back to input
000953  1               r:
000953  1  C0 4F            cpy #'o'        ;r is the first letter, check for "ror" and "rol" instructions
000955  1  D0 32            bne err2        ;only implied address mode implemented rn
000957  1  C9 52            cmp #'r'
000959  1  D0 6C            bne rotl        ;branch when this is not "ror", check for "rol"
00095B  1  A5 28 48 28      lds             ;load and apply status register (this is a macro)
00095F  1  A5 25            lda AR          ;load A register
000961  1  6A               ror             ;rotate A register right
000962  1  85 25            sta AR          ;store A register for other instructions
000964  1  08 68 85 28      sts             ;store the status register (also a macro)
000968  1  4C 10 08         jmp start       ;go back for input
00096B  1               l:
00096B  1  C0 44            cpy #'d'        ;l is the first letter, check for "lda", "ldx", "ldy" and "lsr" instructions
00096D  1  D0 7E            bne ls          ;branch when is "lsr" or invalid
00096F  1  C9 41            cmp #'a'
000971  1  D0 68            bne loadx       ;branch when not "lda"
000973  1  A0 A9            ldy #$A9        ;load the immediate address mode opcode for "lda" to Y
000975  1  A2 AD            ldx #$AD        ;load the absolute address mode opcode for "lda" to X
000977  1  4C 2E 0A         jmp load        ;jump to assembler
00097A  1               j:
00097A  1  C0 53            cpy #'s'        ;j is the first letter, check for "jsr" instruction
00097C  1  D0 0B            bne err2
00097E  1  C9 52            cmp #'r'
000980  1  D0 07            bne err2
000982  1  A2 20            ldx #$20        ;load "jsr" opcode to X
000984  1  A0 00            ldy #0          ;no immediate opcodes for "jsr", 0 is the magic value for that
000986  1  4C 2E 0A         jmp load        ;jump to assembler
000989  1               err2:
000989  1  4C 8F 0A         jmp err         ;jump to error handler
00098C  1               s:                  ;s is the first letter, check for "sec", "sbc", "sta", "stx" and "sty" instructions
00098C  1  C0 45            cpy #'e'
00098E  1  F0 2A            beq se          ;branch when its "se*"
000990  1  C0 42            cpy #'b'
000992  1  F0 1B            beq sb          ;branch when its "sb*"
000994  1  C0 54            cpy #'t'
000996  1  D0 F1            bne err2        ;not branch when its "st*"
000998  1  C9 58            cmp #'x'
00099A  1  F0 4A            beq storx       ;branch when its "stx"
00099C  1  C9 59            cmp #'y'
00099E  1  F0 65            beq story       ;branch when its "sty"
0009A0  1  C9 5A            cmp #'z'
0009A2  1  F0 68            beq st0         ;branch when its "stz"
0009A4  1  C9 41            cmp #'a'
0009A6  1  D0 E1            bne err2        ;not branch when its "sta"
0009A8  1  A2 8D            ldx #$8D        ;load absolute opcode
0009AA  1  A0 00            ldy #0          ;load magic value
0009AC  1  4C 2E 0A         jmp load        ;jump to assembler
0009AF  1               sb:
0009AF  1  C9 43            cmp #'c'
0009B1  1  D0 D6            bne err2        ;not branch when its "sbc"
0009B3  1  A2 ED            ldx #$ED        ;load absolute opcode
0009B5  1  A0 E9            ldy #$E9        ;load immediate opcode
0009B7  1  4C 2E 0A         jmp load        ;jump to assembler
0009BA  1               se:
0009BA  1  C9 43            cmp #'c'
0009BC  1  D0 CB            bne err2        ;not branch when its "sec"
0009BE  1  A5 28            lda $28         ;load status register
0009C0  1  09 01            ora #$1         ;set last bit to 1 or leave last bit at 1, bits in this register are mapped like NV--DIZC
0009C2  1  85 28            sta $28         ;store status register
0009C4  1  4C 10 08         jmp start       ;return for next input
0009C7  1               rotl:               ;implied mode only for now
0009C7  1  C9 4C            cmp #'l'
0009C9  1  D0 BE            bne err2        ;not branch when its "rol"
0009CB  1  A5 28 48 28      lds             ;load and apply status register
0009CF  1  A5 25            lda AR          ;load A register
0009D1  1  2A               rol             ;rotate left
0009D2  1  85 25            sta AR          ;store A register
0009D4  1  08 68 85 28      sts             ;store potentially modified status register
0009D8  1  4C 10 08         jmp start       ;return for next input
0009DB  1               loadx:
0009DB  1  C9 58            cmp #'x'
0009DD  1  D0 34            bne loady       ;not branch when its "ldx"
0009DF  1  A0 A2            ldy #$A2        ;load immediate and absolute opcodes
0009E1  1  A2 AE            ldx #$AE
0009E3  1  4C 2E 0A         jmp load        ;jump to assembler
0009E6  1               storx:
0009E6  1  A2 8E            ldx #$8E        ;load absolute opcode and magic number
0009E8  1  A0 00            ldy #0
0009EA  1  4C 2E 0A         jmp load        ;jump to assembler
0009ED  1               ls:
0009ED  1  C0 53            cpy #'s'
0009EF  1  D0 98            bne err2
0009F1  1  C9 52            cmp #'r'
0009F3  1  D0 94            bne err2        ;not branch when its "lsr"
0009F5  1  A5 28 48 28      lds             ;load and apply the status register
0009F9  1  A5 25            lda AR          ;load A register
0009FB  1  4A               lsr             ;bit shift to the left
0009FC  1  85 25            sta AR          ;store A register
0009FE  1  08 68 85 28      sts             ;store potentially changed status register
000A02  1  4C 10 08         jmp start       ;jump to assembler
000A05  1               story:
000A05  1  A2 8C            ldx #$8C        ;load absolute opcode and magic number
000A07  1  A0 00            ldy #0
000A09  1  4C 2E 0A         jmp load        ;jump to assembler
000A0C  1               st0:
000A0C  1  A2 9C            ldx #$9C        ;load absolute opcode and magic number
000A0E  1  A0 00            ldy #0
000A10  1  4C 2E 0A         jmp load        ;jump to assembler
000A13  1               loady:
000A13  1  C9 59            cmp #'y'
000A15  1  D0 78            bne err         ;not branch when its "ldy"
000A17  1  A0 A0            ldy #$A0        ;load immediate and absolute opcodes
000A19  1  A2 AC            ldx #$AC
000A1B  1  4C 2E 0A         jmp load        ;jump to assembler
000A1E  1               andr:
000A1E  1  C9 24            cmp #$24
000A20  1  D0 6D            bne err         ;not branch when the "$" is detected
000A22  1  86 30            stx ZP          ;store absolute opcode to 1st byte of the code
000A24  1  A2 02            ldx #2          ;load the offset for reading the arguments for reading the last 2 nibbles of the argument
000A26  1  A0 00            ldy #0          ;load the offset for writing the binary code
000A28  1  80 20            bra ldmath      ;branch to decoding the text
000A2A  1               cng:
000A2A  1  85 24            sta $24         ;might not need to branch but whatever
000A2C  1  80 1C            bra ldmath      ;go back to main code
000A2E  1               load:               ;building instruction (or code) with arguments, x = absolute opcode, y = immediate opcode
000A2E  1  A5 33            lda ZP+3        ;check for the space after the instruction input
000A30  1  C9 20            cmp #$20
000A32  1  D0 5B            bne err
000A34  1  A5 34            lda ZP+4        ;check for first symbol of the argument
000A36  1  C9 23            cmp #$23
000A38  1  D0 E4            bne andr        ;not "#" detected, its not immediate address mode
000A3A  1  C0 00            cpy #0          ;check for the magic number
000A3C  1  F0 51            beq err         ;magic number detected, that means that there's no immediate address mode for the instruction.
000A3E  1  84 30            sty ZP          ;store immediate opcode to 1st byte of the code
000A40  1  A0 00            ldy #0          ;load the offset for writing the binary code
000A42  1               here:               ;dis is skipped for the first time running the code for absolute address mode
000A42  1  A2 00            ldx #0          ;load the offset for reading the arguments, read the first 2 nibbles of the argument
000A44  1  A5 23            lda $23         ;load the value for checking for nibble skip
000A46  1  C9 01            cmp #1
000A48  1  F0 E0            beq cng         ;value is 1, branch to change the value for nibble skip to 1
000A4A  1               ldmath:
000A4A  1  B5 35            lda ZP+5,x      ;load the 1st+x nibble
000A4C  1  C9 30            cmp #$30        ;check for "0"
000A4E  1  30 3F            bmi err         ;error out when its less than a number PETSCII code
000A50  1  C9 3A            cmp #$3A        ;check for "9"+1
000A52  1  30 08            bmi dek         ;branch to decimal decoding when it's a number PETSCII code
000A54  1  20 D6 0A         jsr hex         ;jsr to hex decoding subroutine
000A57  1  99 31 00         sta ZP+1,y      ;hex subroutine ended, store decoded value at 2nd or 3rd byte of code
000A5A  1  80 06            bra dig2        ;skip to decoding 2nd+x nibble
000A5C  1               dek:
000A5C  1  38               sec
000A5D  1  E9 30            sbc #$30        ;35('5')-30=5
000A5F  1  99 31 00         sta ZP+1,y      ;store decoded value at 2nd or 3rd byte of code
000A62  1               dig2:
000A62  1  A5 24            lda $24         ;load the nibble skip value
000A64  1  C9 01            cmp #1
000A66  1  F0 4A            beq ender       ;skip to end if nibble skip is set
000A68  1  B5 36            lda ZP+6,x      ;load the 2nd+x nibble
000A6A  1  C9 00            cmp #0          ;check for null terminator
000A6C  1  F0 36            beq ender2      ;only 1 or 3 nibbles are entered but that's fine. skip to the handler of that
000A6E  1  30 1F            bmi err
000A70  1  C9 3A            cmp #$3A        ;the same as previous time
000A72  1  30 28            bmi dek2        ;copy of previous decoder, just it stores decoded bytes ad 3rd or 4th byte at the end it branches to merger
000A74  1  20 D6 0A         jsr hex         ;jsr to hex decoder
000A77  1  99 32 00         sta ZP+2,y      ;store hex subroutine ended, store decoded value at 3rd or 4th byte of code
000A7A  1               merger:
000A7A  1  B9 31 00         lda ZP+1,y      ;load 2nd or 3rd byte of the code
000A7D  1  0A               asl             ;shift the lower nibble to the upper nibble spot
000A7E  1  0A               asl
000A7F  1  0A               asl
000A80  1  0A               asl
000A81  1  18               clc
000A82  1  79 32 00         adc ZP+2,y      ;add this and 3rd or 4th byte of the code
000A85  1  99 31 00         sta ZP+1,y      ;store the new 2nd or 3rd byte of the code
000A88  1  C8               iny             ;increment Y to increment where to store bytes
000A89  1  E0 01            cpx #1          ;check for the read offset of 1 (set by ender2 branch) or 2
000A8B  1  10 B5            bpl here        ;if it's that then loop to the start of the assembler
000A8D  1  80 23            bra ender       ;skip some code and go to the end
000A8F  1               err:                ;error handler
000A8F  1  A9 0D            lda #$0D
000A91  1  20 D2 FF         jsr CHROUT
000A94  1  A9 45            lda #'e'
000A96  1  20 D2 FF         jsr CHROUT      ;output enter and 'e'
000A99  1  4C 10 08         jmp start       ;return to the start
000A9C  1               dek2:
000A9C  1  38               sec
000A9D  1  E9 30            sbc #$30
000A9F  1  99 32 00         sta ZP+2,y
000AA2  1  80 D6            bra merger
000AA4  1               ender2:
000AA4  1  A5 34            lda ZP+4        ;check for the first symbol of the argument again
000AA6  1  C9 24            cmp #$24
000AA8  1  D0 08            bne ender       ;its '#', the program can skip to the end
000AAA  1  A2 01            ldx #1          ;load read offset of 1
000AAC  1  A0 00            ldy #0          ;load write offset of 0
000AAE  1  86 23            stx $23         ;set the value for setting the nibble skip
000AB0  1  80 98            bra ldmath      ;do the assemble routine again with these values
000AB2  1               ender:
000AB2  1  A5 34            lda ZP+4
000AB4  1  C9 24            cmp #$24        ;check for the first symbol of the argument again
000AB6  1  F0 2A            beq alt         ;branch to alternative if its "$"
000AB8  1  A9 60            lda #$60
000ABA  1  85 32            sta ZP+2        ;store "rts" opcode to last (3rd) byte of the code
000ABC  1               ret:
000ABC  1  A6 26            ldx XR
000ABE  1  A4 27            ldy YR
000AC0  1  A5 28 48 28      lds
000AC4  1  A5 25            lda AR          ;load A, X, Y registers and a status register
000AC6  1  20 30 00         jsr ZP          ;jsr to the code that the assembler has built
000AC9  1  85 25            sta AR
000ACB  1  86 26            stx XR
000ACD  1  84 27            sty YR
000ACF  1  08 68 85 28      sts             ;store the registers
000AD3  1  4C 10 08         jmp start       ;jump to the start
000AD6  1               hex:                ;hex decoder
000AD6  1  C9 41            cmp #$41
000AD8  1  30 B5            bmi err         ;branch if input is less than PETSCII "A"
000ADA  1  C9 47            cmp #$47
000ADC  1  10 B1            bpl err         ;branch if input is more than PETSCII "F"
000ADE  1  38               sec
000ADF  1  E9 37            sbc #$37        ;$42-$37=$0B
000AE1  1  60               rts             ;return to writing bytes
000AE2  1               alt:
000AE2  1  A9 60            lda #$60
000AE4  1  85 33            sta ZP+3        ;store "rts" opcode to 4th byte of the code
000AE6  1  80 D4            bra ret         ;go back to the main program
000AE6  1               
